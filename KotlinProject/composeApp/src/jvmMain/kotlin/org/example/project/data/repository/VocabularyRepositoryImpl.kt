package org.example.project.data.repository

import io.github.jan.supabase.postgrest.postgrest
import io.github.jan.supabase.postgrest.query.Columns
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import org.example.project.core.config.SupabaseConfig
import org.example.project.domain.model.VocabularyStatus
import org.example.project.domain.model.VocabularyWord


class VocabularyRepositoryImpl : VocabularyRepository {

    private val supabase = SupabaseConfig.client

    override suspend fun getAllVocabularyWords(): Result<List<VocabularyWord>> = runCatching {
        val rows = supabase.postgrest["vocabulary_words"]
            .select()
            .decodeAs<List<VocabularyWordDTO>>()
        rows.map { it.toDomain() }
    }

    override suspend fun searchVocabularyWords(query: String): Result<List<VocabularyWord>> = runCatching {
        val rows = supabase.postgrest["vocabulary_words"]
            .select {
                filter {
                    or {
                        ilike("word", "%$query%")
                        ilike("definition", "%$query%")
                    }
                }
            }
            .decodeAs<List<VocabularyWordDTO>>()
        rows.map { it.toDomain() }
    }

    override suspend fun addVocabularyWord(word: VocabularyWord): Result<VocabularyWord> = runCatching {
        val inserted = supabase.postgrest["vocabulary_words"]
            .insert(
                value = VocabularyWordDTO.fromDomain(word)
            ) {
                select(Columns.ALL)
            }
            .decodeAs<VocabularyWordDTO>()
        inserted.toDomain()
    }

    // Not yet implemented â€“ return simple defaults to keep UI functional
    override suspend fun getVocabularyWordsByCategory(category: String) = Result.success(emptyList<VocabularyWord>())
    override suspend fun getVocabularyWordsByDifficulty(difficulty: String) = Result.success(emptyList<VocabularyWord>())
    override suspend fun getVocabularyWord(wordId: String) = Result.success<VocabularyWord?>(null)
    override suspend fun updateVocabularyWord(word: VocabularyWord) = Result.success(word)
    override suspend fun deleteVocabularyWord(wordId: String) = Result.success(Unit)
    override suspend fun getUserVocabulary(userId: String) = Result.success(emptyList<UserVocabularyWord>())
    override suspend fun addWordToUserVocabulary(userId: String, wordId: String) = Result.failure<UserVocabularyWord>(NotImplementedError())
    override suspend fun updateUserWordStatus(userId: String, wordId: String, status: VocabularyStatus) = Result.success(Unit)
    override suspend fun getUserWordsByStatus(userId: String, status: VocabularyStatus) = Result.success(emptyList<UserVocabularyWord>())
    override suspend fun removeWordFromUserVocabulary(userId: String, wordId: String) = Result.success(Unit)
    override suspend fun getUserVocabularyStats(userId: String) = Result.success(VocabularyStats(0, 0, 0, 0, 0, 0, 0))
    override suspend fun getWordsForReview(userId: String, limit: Int) = Result.success(emptyList<UserVocabularyWord>())
}


@Serializable
private data class VocabularyWordDTO(
    val id: String? = null,
    val word: String,
    val definition: String,
    val pronunciation: String? = null,
    @SerialName("example_sentence") val exampleSentence: String? = null,
    @SerialName("difficulty_level") val difficultyLevel: String,
    val category: String,
    @SerialName("audio_url") val audioUrl: String? = null,
    @SerialName("image_url") val imageUrl: String? = null,
    @SerialName("created_at") val createdAt: String? = null,
    @SerialName("updated_at") val updatedAt: String? = null
) {
    fun toDomain(): VocabularyWord {
        return VocabularyWord(
            id = id ?: "",
            word = word,
            definition = definition,
            pronunciation = pronunciation ?: "",
            category = category,
            difficulty = difficultyLevel,
            examples = exampleSentence?.let { listOf(it) } ?: emptyList(),
            status = VocabularyStatus.NEW,
            dateAdded = System.currentTimeMillis(),
            lastReviewed = null
        )
    }

    companion object {
        fun fromDomain(w: VocabularyWord): VocabularyWordDTO {
            return VocabularyWordDTO(
                // id is generated by the DB; omit to let Postgres assign UUID
                word = w.word,
                definition = w.definition,
                pronunciation = w.pronunciation.ifBlank { null },
                exampleSentence = w.examples.firstOrNull(),
                difficultyLevel = w.difficulty.ifBlank { "Beginner" },
                category = w.category.ifBlank { "General" },
                audioUrl = null,
                imageUrl = null
            )
        }
    }
}